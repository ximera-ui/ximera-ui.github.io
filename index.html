<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Obsidian | @ebymamashu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        :root {
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --primary-glow: rgba(59, 130, 246, 0.5);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
            color: #FFFFFF;
            user-select: none;
        }

        #bg-container {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: -2;
            overflow: hidden;
            background: #050505;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bg-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover; 
            display: none;
            transition: opacity 0.3s ease;
        }

        #canvas-container {
            position: relative;
            touch-action: none; /* enable custom touch gestures */
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
            z-index: 1;
        }

        .sidebar {
            background: rgba(10, 10, 10, 0.75);
            backdrop-filter: blur(25px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
        }

        .node-btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            transition: all 0.2s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .node-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.02);
        }

        .active-mode { 
            background: var(--primary-color) !important; 
            border-color: var(--primary-color) !important; 
            box-shadow: 0 0 15px var(--primary-glow);
        }
        .active-trash { background: #990000 !important; border-color: #ff4444 !important; }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #111;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 24px;
            border-radius: 20px;
            width: 340px;
        }

        .input-hq {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 16px;
            width: 100%;
            color: white;
            outline: none;
            font-size: 13px;
            margin: 16px 0;
        }

        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 12px;
        }

        #file-input, #bg-upload-input, #bg-video-upload-input { display: none; }
        #icon-stager { position: absolute; visibility: hidden; pointer-events: none; }

        .text-theme { color: var(--primary-color); }
        .bg-theme { background-color: var(--primary-color); }
        .border-theme { border-color: var(--primary-color); }
        .accent-theme { accent-color: var(--primary-color); }
    </style>
</head>
<body>

    <div id="bg-container">
        <div id="default-bg" class="bg-layer" style="display: block; background: radial-gradient(circle at center, #0a0a0a 0%, #050505 100%);"></div>
        <img id="image-bg" class="bg-layer" src="" alt="">
        <video id="video-bg" class="bg-layer" loop muted playsinline></video>
    </div>

    <!-- Modals (Nodes, Settings) -->
    <div id="nodeModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="modalTitle" class="text-[10px] font-bold uppercase tracking-widest text-theme">Объект</h3>
            <input type="text" id="modalInput" class="input-hq" placeholder="Введите данные...">
            <div class="flex gap-2">
                <button onclick="closeModal('nodeModal')" class="flex-1 py-2.5 rounded-lg bg-white/5 hover:bg-white/10 text-[10px] font-bold uppercase tracking-wider">Отмена</button>
                <button id="modalConfirm" class="flex-1 py-2.5 rounded-lg bg-theme hover:opacity-80 text-[10px] font-bold uppercase tracking-wider">Сохранить</button>
            </div>
        </div>
    </div>

    <div id="bgModal" class="modal-overlay">
        <div class="modal-content w-[380px]">
            <h3 class="text-[10px] font-bold uppercase tracking-widest text-theme mb-4">Настройки и Визуал</h3>
            <div class="toggle-container border border-white/5">
                <div><span class="text-[9px] font-bold text-white uppercase tracking-widest">Основной цвет темы</span></div>
                <input type="color" id="themeColorPicker" value="#3b82f6" oninput="updateThemeColor(this.value)" class="w-8 h-8 rounded border-0 bg-transparent cursor-pointer">
            </div>
            <div class="toggle-container border border-white/5">
                <div><span class="text-[9px] font-bold text-white uppercase tracking-widest">Плавные линии</span></div>
                <input type="checkbox" id="lineStyleToggle" checked onchange="toggleLineStyle(this.checked)" class="w-5 h-5 accent-theme">
            </div>
            <div class="grid grid-cols-2 gap-3 mb-4">
                <button onclick="document.getElementById('bg-upload-input').click()" class="p-4 bg-white/5 border border-white/10 rounded-xl hover:bg-white/10 flex flex-col items-center gap-2 transition">
                    <i data-lucide="image" class="w-5 h-5 text-white/70"></i>
                    <span class="text-[8px] font-bold uppercase text-white">Фото / GIF</span>
                </button>
                <button onclick="document.getElementById('bg-video-upload-input').click()" class="p-4 bg-white/5 border border-white/10 rounded-xl hover:bg-white/10 flex flex-col items-center gap-2 transition">
                    <i data-lucide="clapperboard" class="w-5 h-5 text-white/70"></i>
                    <span class="text-[8px] font-bold uppercase text-white">Видео-фон</span>
                </button>
            </div>
            <div class="bg-white/5 p-4 rounded-xl border border-white/10 mb-4">
                <div class="flex justify-between items-center mb-3">
                    <span class="text-[8px] font-bold text-white/40 uppercase tracking-widest">Масштабирование</span>
                    <div class="flex gap-1">
                        <button onclick="updateBgFitting('cover')" class="px-2 py-1 rounded bg-white/5 text-[7px] font-bold border border-white/5 uppercase">Заполнить</button>
                        <button onclick="updateBgFitting('contain')" class="px-2 py-1 rounded bg-white/5 text-[7px] font-bold border border-white/5 uppercase">Вписать</button>
                    </div>
                </div>
                <div>
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-[8px] font-bold text-white/40 uppercase tracking-widest">Прозрачность</span>
                        <span id="opacity-val" class="text-[8px] font-bold text-theme">100%</span>
                    </div>
                    <input type="range" id="bg-opacity" min="0" max="1" step="0.01" value="1" class="w-full h-1 bg-white/10 rounded appearance-none cursor-pointer accent-theme" oninput="updateBgOpacity(this.value)">
                </div>
            </div>
            <div class="flex gap-2">
                <button onclick="resetBackground()" class="flex-1 py-2 rounded-lg bg-red-900/10 text-red-500 border border-red-900/20 hover:bg-red-900/20 text-[9px] font-bold uppercase">Сброс фона</button>
                <button onclick="closeModal('bgModal')" class="flex-1 py-2 rounded-lg bg-white/10 text-white hover:bg-white/20 text-[9px] font-bold uppercase">Закрыть</button>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept="image/*">
    <input type="file" id="bg-upload-input" accept="image/*,image/gif">
    <input type="file" id="bg-video-upload-input" accept="video/mp4,video/webm">
    <div id="icon-stager"></div>

    <div id="canvas-container">
        <canvas id="graphCanvas"></canvas>
    </div>

    <!-- Sidebar UI -->
    <div class="fixed top-6 left-6 w-[240px] sidebar rounded-[24px] p-5 flex flex-col gap-4 z-50">
        <div class="flex items-center justify-between mb-1">
            <div>
                <h1 class="text-xs font-black text-white tracking-wider uppercase">OSINT Engine</h1>
                <p class="text-[8px] font-bold text-theme uppercase tracking-[2px] opacity-60">Release 1.3</p>
            </div>
            <div class="w-8 h-8 rounded-full bg-theme/10 flex items-center justify-center">
                <i data-lucide="shield-check" class="w-4 h-4 text-theme"></i>
            </div>
        </div>
        
        <div class="grid grid-cols-2 gap-2">
            <button onclick="promptNode('PERSON')" class="node-btn h-10 rounded-xl flex flex-col items-center justify-center gap-0.5"><i data-lucide="user-search" class="w-3.5 h-3.5 text-white/70"></i><span class="text-[6px] font-bold opacity-50 uppercase">Личность</span></button>
            <button onclick="promptNode('BIRTHDAY')" class="node-btn h-10 rounded-xl flex flex-col items-center justify-center gap-0.5"><i data-lucide="cake" class="w-3.5 h-3.5 text-white/70"></i><span class="text-[6px] font-bold opacity-50 uppercase">Дата Рожд.</span></button>
            <button onclick="promptNode('COMPANY')" class="node-btn h-10 rounded-xl flex flex-col items-center justify-center gap-0.5"><i data-lucide="briefcase" class="w-3.5 h-3.5 text-white/70"></i><span class="text-[6px] font-bold opacity-50 uppercase">Компания</span></button>
            <button onclick="promptNode('DOMAIN')" class="node-btn h-10 rounded-xl flex flex-col items-center justify-center gap-0.5"><i data-lucide="globe" class="w-3.5 h-3.5 text-white/70"></i><span class="text-[6px] font-bold opacity-50 uppercase">Домен</span></button>
            <button onclick="promptNode('IP')" class="node-btn h-10 rounded-xl flex flex-col items-center justify-center gap-0.5"><i data-lucide="network" class="w-3.5 h-3.5 text-white/70"></i><span class="text-[6px] font-bold opacity-50 uppercase">IP Адрес</span></button>
            <button onclick="promptNode('PHONE')" class="node-btn h-10 rounded-xl flex flex-col items-center justify-center gap-0.5"><i data-lucide="phone" class="w-3.5 h-3.5 text-white/70"></i><span class="text-[6px] font-bold opacity-50 uppercase">Телефон</span></button>
            <button onclick="promptNode('CITY')" class="node-btn h-10 rounded-xl flex flex-col items-center justify-center gap-0.5"><i data-lucide="map-pin" class="w-3.5 h-3.5 text-white/70"></i><span class="text-[6px] font-bold opacity-50 uppercase">Город</span></button>
            <button onclick="addNode('IMAGE')" class="node-btn h-10 rounded-xl flex flex-col items-center justify-center gap-0.5"><i data-lucide="camera" class="w-3.5 h-3.5 text-white/70"></i><span class="text-[6px] font-bold opacity-50 uppercase">Фотография</span></button>
        </div>

        <div class="h-[1px] bg-white/5"></div>

        <div class="flex flex-col gap-2">
            <span class="text-[7px] font-bold text-white/30 uppercase tracking-widest ml-1">Инструменты</span>
            <div class="grid grid-cols-3 gap-2">
                <button id="drawRectBtn" onclick="toggleMode('drawRect')" class="node-btn h-10 rounded-xl flex items-center justify-center" title="Квадрат"><i data-lucide="square" class="w-4 h-4 text-white/70"></i></button>
                <button id="drawCircleBtn" onclick="toggleMode('drawCircle')" class="node-btn h-10 rounded-xl flex items-center justify-center" title="Эллипс"><i data-lucide="circle" class="w-4 h-4 text-white/70"></i></button>
                <button id="drawArrowBtn" onclick="toggleMode('drawArrow')" class="node-btn h-10 rounded-xl flex items-center justify-center" title="Стрелка"><i data-lucide="move-up-right" class="w-4 h-4 text-white/70"></i></button>
            </div>
        </div>

        <div class="h-[1px] bg-white/5"></div>

        <button onclick="openModal('bgModal')" class="w-full h-10 node-btn rounded-xl flex items-center justify-between px-4 group">
            <div class="flex items-center gap-3"><div class="w-6 h-6 rounded-md bg-white/5 flex items-center justify-center"><i data-lucide="palette" class="w-3.5 h-3.5 text-white/70"></i></div><span class="text-[9px] font-bold uppercase tracking-widest opacity-80">Визуал</span></div>
            <i data-lucide="chevron-right" class="w-3 h-3 opacity-20 group-hover:translate-x-1 transition"></i>
        </button>

        <div class="flex gap-2">
            <button id="linkBtn" onclick="toggleMode('link')" class="flex-1 h-10 node-btn rounded-xl flex items-center justify-center gap-2 text-[9px] font-bold"><i data-lucide="plus-circle" class="w-3.5 h-3.5 text-white/70"></i> СВЯЗЬ</button>
            <button id="trashBtn" onclick="toggleMode('trash')" class="w-10 h-10 node-btn rounded-xl flex items-center justify-center" title="Удалить"><i data-lucide="trash-2" class="w-3.5 h-3.5 text-red-500"></i></button>
        </div>

        <button onclick="downloadProject()" class="w-full h-10 node-btn rounded-xl flex items-center justify-center gap-2 text-[9px] font-bold text-theme border-theme/30 bg-theme/10 hover:bg-theme/20"><i data-lucide="save" class="w-3.5 h-3.5"></i> ЭКСПОРТ (PNG)</button>
    </div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('file-input');
        const bgUploadInput = document.getElementById('bg-upload-input');
        const bgVideoUploadInput = document.getElementById('bg-video-upload-input');
        const iconStager = document.getElementById('icon-stager');

        const layers = {
            default: document.getElementById('default-bg'),
            image: document.getElementById('image-bg'),
            video: document.getElementById('video-bg')
        };

        let nodes = [];
        let edges = [];
        let shapes = []; 
        let offset = { x: 0, y: 0 };
        let zoom = 1;
        let isDragging = false;
        let dragNode = null;
        let dragShape = null;
        let selectedNode = null;
        let lastMousePos = { x: 0, y: 0 };
        let currentMode = 'select';
        let linkSource = null;
        let lastClickTime = 0;
        let useCurvedLines = true;
        let activeShape = null; 
        let primaryColor = '#3b82f6';

        const NODE_RADIUS = 36;
        const ICON_MAP = {
            'PERSON': 'user-search', 'BIRTHDAY': 'cake', 'COMPANY': 'briefcase',
            'DOMAIN': 'globe', 'IP': 'network', 'PHONE': 'phone', 'CITY': 'map-pin'
        };

        const iconCache = {};

        function openModal(id) { document.getElementById(id).style.display = 'flex'; }
        function closeModal(id) { document.getElementById(id).style.display = 'none'; }
        
        function updateThemeColor(color) {
            primaryColor = color;
            document.documentElement.style.setProperty('--primary-color', color);
            document.documentElement.style.setProperty('--primary-glow', color + '80');
            draw();
        }

        function toggleLineStyle(isCurved) {
            useCurvedLines = isCurved;
            draw();
        }

        // Project logic functions...
        function promptNode(type, existingNode = null) {
            const modal = document.getElementById('nodeModal');
            const title = document.getElementById('modalTitle');
            const input = document.getElementById('modalInput');
            const confirm = document.getElementById('modalConfirm');

            title.innerText = existingNode ? `Редактировать: ${existingNode.type}` : `Добавить: ${type}`;
            input.value = existingNode ? existingNode.content : '';
            confirm.innerText = existingNode ? 'Сохранить' : 'Добавить';
            
            openModal('nodeModal');
            setTimeout(() => input.focus(), 50);

            const handleConfirm = () => {
                const val = input.value.trim().toUpperCase();
                if (val) {
                    if (existingNode) existingNode.content = val;
                    else createNodeObject(type, val);
                    closeModal('nodeModal');
                    draw();
                }
                confirm.onclick = null;
            };

            confirm.onclick = handleConfirm;
            input.onkeydown = (e) => { if(e.key === 'Enter') handleConfirm(); };
        }

        function updateBgFitting(mode) { layers.image.style.objectFit = mode; layers.video.style.objectFit = mode; }
        function updateBgOpacity(val) {
            layers.image.style.opacity = val;
            layers.video.style.opacity = val;
            document.getElementById('opacity-val').innerText = Math.round(val * 100) + '%';
        }

        function setBgLayer(activeType) {
            Object.keys(layers).forEach(key => {
                layers[key].style.display = (key === activeType) ? 'block' : 'none';
                if (key === 'video' && key !== activeType) layers[key].pause();
            });
            draw();
        }

        function resetBackground() {
            setBgLayer('default');
            updateBgFitting('cover');
            updateBgOpacity(1);
            document.getElementById('bg-opacity').value = 1;
        }

        bgUploadInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                layers.image.onload = () => { setBgLayer('image'); };
                layers.image.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        bgVideoUploadInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            layers.video.onloadedmetadata = () => {
                setBgLayer('video');
                layers.video.play();
            };
            layers.video.src = url;
        };

        async function preRenderIcons() {
            if (typeof lucide === 'undefined') return setTimeout(preRenderIcons, 100);
            for (const [type, iconName] of Object.entries(ICON_MAP)) {
                const temp = document.createElement('div');
                const i = document.createElement('i');
                i.setAttribute('data-lucide', iconName);
                temp.appendChild(i);
                iconStager.appendChild(temp);
                lucide.createIcons({
                    nameAttr: 'data-lucide',
                    attrs: { stroke: '#FFFFFF', 'stroke-width': '2.5', width: '48', height: '48' }
                });
                const svg = temp.querySelector('svg');
                if (!svg) continue;
                const svgString = new XMLSerializer().serializeToString(svg);
                const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const img = new Image();
                img.src = url;
                await new Promise(r => {
                    img.onload = () => {
                        const off = document.createElement('canvas');
                        off.width = 64; off.height = 64;
                        const oCtx = off.getContext('2d');
                        oCtx.drawImage(img, 8, 8, 48, 48);
                        iconCache[type] = off;
                        URL.revokeObjectURL(url);
                        r();
                    };
                });
                iconStager.removeChild(temp);
            }
            draw();
        }

        window.addNode = (type) => {
            if (type === 'IMAGE') {
                fileInput.onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = ev => createNodeObject('IMAGE', file.name, ev.target.result);
                    reader.readAsDataURL(file);
                };
                fileInput.click();
            }
        };

        function createNodeObject(type, content, imgData = null) {
            const newNode = {
                id: Math.random().toString(36).substr(2, 9),
                type, content: content.toUpperCase(),
                x: (window.innerWidth / 2 - offset.x) / zoom,
                y: (window.innerHeight / 2 - offset.y) / zoom,
                img: null, scale: 0
            };
            if (imgData) {
                const img = new Image();
                img.src = imgData;
                img.onload = () => { newNode.img = img; draw(); };
            }
            nodes.push(newNode);
            animateNodeEntry(newNode);
        }

        function animateNodeEntry(node) {
            let start = null;
            const step = (t) => {
                if (!start) start = t;
                const p = Math.min((t - start) / 300, 1);
                node.scale = p < 1 ? 1.1 * p : 1;
                draw();
                if (p < 1) requestAnimationFrame(step);
            };
            requestAnimationFrame(step);
        }

        window.toggleMode = (mode) => {
            currentMode = currentMode === mode ? 'select' : mode;
            linkSource = null;
            
            document.getElementById('linkBtn').classList.toggle('active-mode', currentMode === 'link');
            document.getElementById('trashBtn').classList.toggle('active-trash', currentMode === 'trash');
            document.getElementById('drawRectBtn').classList.toggle('active-mode', currentMode === 'drawRect');
            document.getElementById('drawCircleBtn').classList.toggle('active-mode', currentMode === 'drawCircle');
            document.getElementById('drawArrowBtn').classList.toggle('active-mode', currentMode === 'drawArrow');
            
            canvas.style.cursor = (currentMode.startsWith('draw')) ? 'crosshair' : 'grab';
            draw();
        };

        function draw(renderCtx = ctx, isExport = false) {
            const c = renderCtx.canvas;
            renderCtx.setTransform(1, 0, 0, 1, 0, 0);
            
            if (isExport) {
                renderCtx.fillStyle = '#050505';
                renderCtx.fillRect(0, 0, c.width, c.height);
                if (layers.image.style.display !== 'none' && layers.image.complete) {
                    renderCtx.globalAlpha = parseFloat(layers.image.style.opacity) || 1;
                    const iw = layers.image.naturalWidth, ih = layers.image.naturalHeight;
                    const sc = Math.max(c.width / iw, c.height / ih);
                    renderCtx.drawImage(layers.image, (c.width - iw*sc)/2, (c.height - ih*sc)/2, iw*sc, ih*sc);
                    renderCtx.globalAlpha = 1;
                }
            } else {
                renderCtx.clearRect(0, 0, c.width, c.height);
                renderCtx.translate(offset.x, offset.y);
                renderCtx.scale(zoom, zoom);
                drawGrid(renderCtx);
            }

            shapes.forEach(s => drawShape(s, renderCtx, isExport));
            if (activeShape) drawShape(activeShape, renderCtx, isExport);

            edges.forEach(e => {
                const f = nodes.find(n => n.id === e.from);
                const t = nodes.find(n => n.id === e.to);
                if (f && t) drawEdge(f, t, renderCtx, isExport);
            });

            nodes.forEach(n => {
                const s = n.scale || 0; if (s === 0) return;
                const r = NODE_RADIUS * (isExport ? 1 : s);
                renderCtx.save();
                renderCtx.translate(n.x, n.y);
                
                renderCtx.beginPath();
                renderCtx.arc(0, 0, r, 0, Math.PI * 2);
                const grad = renderCtx.createRadialGradient(0, 0, 0, 0, 0, r);
                grad.addColorStop(0, '#1a1a1a'); grad.addColorStop(1, '#000000');
                renderCtx.fillStyle = grad; renderCtx.fill();

                if (n.type === 'IMAGE' && n.img) {
                    renderCtx.save();
                    renderCtx.beginPath(); renderCtx.arc(0, 0, r - 2, 0, Math.PI * 2); renderCtx.clip();
                    const sc = Math.max((r*2)/n.img.width, (r*2)/n.img.height);
                    renderCtx.drawImage(n.img, -n.img.width*sc/2, -n.img.height*sc/2, n.img.width*sc, n.img.height*sc);
                    renderCtx.restore();
                } else if (iconCache[n.type]) {
                    const is = 32 * (isExport ? 1 : s);
                    renderCtx.drawImage(iconCache[n.type], -is/2, -is/2, is, is);
                }

                renderCtx.strokeStyle = (linkSource === n) ? primaryColor : (selectedNode === n && !isExport ? '#FFF' : 'rgba(255,255,255,0.1)');
                renderCtx.lineWidth = (selectedNode === n ? 3 : 1.5) / (isExport ? 1 : zoom);
                renderCtx.stroke();
                if (n.type !== 'IMAGE') drawLabel(n, r, renderCtx, isExport);
                renderCtx.restore();
            });
        }

        function drawShape(s, rCtx, isExp) {
            rCtx.save();
            rCtx.strokeStyle = primaryColor;
            rCtx.lineWidth = 4 / (isExp ? 1 : zoom);
            rCtx.lineCap = 'round';
            rCtx.lineJoin = 'round';

            if (s.type === 'rect') {
                rCtx.strokeRect(s.x, s.y, s.w, s.h);
            } else if (s.type === 'circle') {
                rCtx.beginPath();
                rCtx.ellipse(s.x + s.w/2, s.y + s.h/2, Math.abs(s.w/2), Math.abs(s.h/2), 0, 0, Math.PI * 2);
                rCtx.stroke();
            } else if (s.type === 'arrow') {
                const tx = s.x + s.w, ty = s.y + s.h;
                const headSize = 18 / (isExp ? 1 : zoom);
                const angle = Math.atan2(s.h, s.w);
                
                // Исправленное положение наконечника стрелки (линия не заходит внутрь острия)
                const lineEndX = tx - (headSize - 2) * Math.cos(angle);
                const lineEndY = ty - (headSize - 2) * Math.sin(angle);

                rCtx.beginPath();
                rCtx.moveTo(s.x, s.y);
                rCtx.lineTo(lineEndX, lineEndY);
                rCtx.stroke();
                
                rCtx.beginPath();
                rCtx.moveTo(tx, ty);
                rCtx.lineTo(tx - headSize * Math.cos(angle - 0.5), ty - headSize * Math.sin(angle - 0.5));
                rCtx.lineTo(tx - headSize * Math.cos(angle + 0.5), ty - headSize * Math.sin(angle + 0.5));
                rCtx.closePath();
                rCtx.fillStyle = primaryColor;
                rCtx.fill();
            }
            rCtx.restore();
        }

        function drawEdge(n1, n2, rCtx, isExp) {
            rCtx.save();
            rCtx.strokeStyle = primaryColor + 'B3'; 
            rCtx.lineWidth = 2 / (isExp ? 1 : zoom);
            
            const dx = n2.x - n1.x, dy = n2.y - n1.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < NODE_RADIUS * 2) { rCtx.restore(); return; }
            
            const nx = dx / dist, ny = dy / dist;
            const sX = n1.x + nx * NODE_RADIUS, sY = n1.y + ny * NODE_RADIUS;
            
            const headSize = 12 / (isExp ? 1 : zoom);
            const gap = 4 / (isExp ? 1 : zoom);
            const eX = n2.x - nx * (NODE_RADIUS + gap);
            const eY = n2.y - ny * (NODE_RADIUS + gap);
            
            // Расчет точки остановки линии (чтобы не заходила под наконечник)
            const lineEndX = eX - headSize * nx;
            const lineEndY = eY - headSize * ny;

            rCtx.beginPath();
            rCtx.moveTo(sX, sY);
            
            let angle;
            if (useCurvedLines) {
                // Плавная S-образная кривая
                const cp1X = sX + (n2.x > n1.x ? 50 : -50);
                const cp1Y = sY;
                const cp2X = lineEndX + (n2.x > n1.x ? -50 : 50);
                const cp2Y = lineEndY;
                
                rCtx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, lineEndX, lineEndY);
                rCtx.stroke();
                angle = Math.atan2(lineEndY - cp2Y, lineEndX - cp2X);
            } else {
                rCtx.lineTo(lineEndX, lineEndY);
                rCtx.stroke();
                angle = Math.atan2(lineEndY - sY, lineEndX - sX);
            }
            
            // Наконечник
            rCtx.beginPath();
            rCtx.moveTo(eX, eY);
            rCtx.lineTo(eX - headSize * Math.cos(angle - 0.4), eY - headSize * Math.sin(angle - 0.4));
            rCtx.lineTo(eX - headSize * Math.cos(angle + 0.4), eY - headSize * Math.sin(angle + 0.4));
            rCtx.closePath();
            rCtx.fillStyle = primaryColor;
            rCtx.fill();
            rCtx.restore();
        }

        function drawGrid(rCtx) {
            const size = 60;
            const l = -offset.x/zoom, t = -offset.y/zoom;
            const r = l + canvas.width/zoom, b = t + canvas.height/zoom;
            rCtx.beginPath(); rCtx.strokeStyle = 'rgba(255, 255, 255, 0.03)'; rCtx.lineWidth = 1/zoom;
            for (let x = Math.floor(l/size)*size; x < r; x += size) { rCtx.moveTo(x, t); rCtx.lineTo(x, b); }
            for (let y = Math.floor(t/size)*size; y < b; y += size) { rCtx.moveTo(l, y); rCtx.lineTo(r, y); }
            rCtx.stroke();
        }

        function drawLabel(n, radius, rCtx, isExp) {
            if (!n.content) return;
            const text = n.content.length > 20 ? n.content.substring(0, 17) + '...' : n.content;
            rCtx.font = `600 ${10 / (isExp ? 1 : zoom)}px Inter`;
            const w = rCtx.measureText(text).width + 16;
            rCtx.fillStyle = 'rgba(0,0,0,0.85)';
            rCtx.beginPath(); rCtx.roundRect(-w/2, radius + 12, w, 22, 8); rCtx.fill();
            rCtx.fillStyle = '#FFFFFF'; rCtx.textAlign = 'center'; rCtx.textBaseline = 'middle';
            rCtx.fillText(text, 0, radius + 23);
        }

        function isPointInShape(mx, my, s) {
            if (s.type === 'rect') {
                const x = Math.min(s.x, s.x + s.w), y = Math.min(s.y, s.y + s.h);
                const w = Math.abs(s.w), h = Math.abs(s.h);
                return mx >= x && mx <= x + w && my >= y && my <= y + h;
            }
            if (s.type === 'circle') {
                const cx = s.x + s.w/2, cy = s.y + s.h/2;
                const rx = Math.abs(s.w/2), ry = Math.abs(s.h/2);
                if (rx === 0 || ry === 0) return false;
                return (Math.pow(mx - cx, 2) / Math.pow(rx, 2)) + (Math.pow(my - cy, 2) / Math.pow(ry, 2)) <= 1;
            }
            if (s.type === 'arrow') {
                const x1 = s.x, y1 = s.y, x2 = s.x + s.w, y2 = s.y + s.h;
                const distToLine = Math.abs((y2-y1)*mx - (x2-x1)*my + x2*y1 - y2*x1) / Math.sqrt(Math.pow(y2-y1, 2) + Math.pow(x2-x1, 2));
                const withinBounds = mx >= Math.min(x1, x2)-15 && mx <= Math.max(x1, x2)+15 && my >= Math.min(y1, y2)-15 && my <= Math.max(y1, y2)+15;
                return distToLine < 15 && withinBounds;
            }
            return false;
        }

        window.downloadProject = () => {
            if (!nodes.length && !shapes.length) return;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            [...nodes, ...shapes].forEach(n => {
                const padding = 200;
                const nx = n.x, ny = n.y;
                minX = Math.min(minX, nx - padding); minY = Math.min(minY, ny - padding);
                maxX = Math.max(maxX, nx + padding); maxY = Math.max(maxY, ny + padding);
            });
            if (minX === Infinity) { minX = 0; minY = 0; maxX = canvas.width; maxY = canvas.height; }
            const dpr = 2;
            const exp = document.createElement('canvas');
            exp.width = (maxX - minX) * dpr; exp.height = (maxY - minY) * dpr;
            const eCtx = exp.getContext('2d');
            eCtx.scale(dpr, dpr); eCtx.translate(-minX, -minY);
            draw(eCtx, true);
            const link = document.createElement('a');
            link.download = `osint-map-${Date.now()}.png`;
            link.href = exp.toDataURL('image/png', 1.0);
            link.click();
        };

        // --- Pointer / Touch support (works on PC + phones) ---
// Notes:
// - Tap selects / triggers link/trash logic
// - Press + move drags nodes/shapes or pans the canvas
// - Two-finger pinch zoom supported on mobile
// - Double tap (or double click) edits a node in select mode

const pointers = new Map(); // pointerId -> {x,y,clientX,clientY}
let isPinching = false;
let pinchStartDist = 0;
let pinchStartZoom = 1;
let pinchWorldCenter = { x: 0, y: 0 };
let pinchScreenCenter = { x: 0, y: 0 };

let downInfo = null; // {time, clientX, clientY, worldX, worldY, hitNode, hitShape}

function getWorldFromClient(clientX, clientY) {
    const r = canvas.getBoundingClientRect();
    return {
        x: (clientX - r.left - offset.x) / zoom,
        y: (clientY - r.top - offset.y) / zoom
    };
}

function distance(a, b) {
    const dx = a.clientX - b.clientX;
    const dy = a.clientY - b.clientY;
    return Math.hypot(dx, dy);
}

function avgPoint(a, b) {
    return { clientX: (a.clientX + b.clientX) / 2, clientY: (a.clientY + b.clientY) / 2 };
}

function setZoomAtScreenPoint(newZoom, screenX, screenY) {
    const r = canvas.getBoundingClientRect();
    const mx = screenX - r.left;
    const my = screenY - r.top;
    const wx = (mx - offset.x) / zoom;
    const wy = (my - offset.y) / zoom;

    zoom = Math.min(Math.max(0.1, newZoom), 5);
    offset.x = mx - wx * zoom;
    offset.y = my - wy * zoom;
}

canvas.addEventListener('pointerdown', (e) => {
    // Capture pointer so we continue receiving move events
    canvas.setPointerCapture(e.pointerId);

    // Track pointer
    pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

    // If 2 pointers => start pinch
    if (pointers.size === 2) {
        const [p1, p2] = Array.from(pointers.values());
        isPinching = true;
        pinchStartDist = distance(p1, p2);
        pinchStartZoom = zoom;

        const c = avgPoint(p1, p2);
        pinchScreenCenter = { x: c.clientX, y: c.clientY };
        pinchWorldCenter = getWorldFromClient(c.clientX, c.clientY);

        // Cancel any drags/pans while pinching
        isDragging = false;
        dragNode = null;
        dragShape = null;
        activeShape = null;
        downInfo = null;
        return;
    }

    const m = getWorldFromClient(e.clientX, e.clientY);

    if (currentMode === 'trash') {
        const shapeIdx = shapes.findIndex(s => isPointInShape(m.x, m.y, s));
        if (shapeIdx !== -1) { shapes.splice(shapeIdx, 1); draw(); return; }
    }

    const hit = nodes.slice().reverse().find(n => Math.hypot(n.x - m.x, n.y - m.y) < NODE_RADIUS);

    // Store down info to decide tap vs drag
    downInfo = {
        time: Date.now(),
        clientX: e.clientX,
        clientY: e.clientY,
        worldX: m.x,
        worldY: m.y,
        hitNode: hit || null,
        hitShape: null
    };

    if (currentMode.startsWith('draw')) {
        activeShape = { type: currentMode.replace('draw', '').toLowerCase(), x: m.x, y: m.y, w: 0, h: 0 };
        draw();
        return;
    }

    if (hit) {
        const now = Date.now();
        if (now - lastClickTime < 300 && currentMode === 'select') { promptNode(hit.type, hit); return; }
        lastClickTime = now;

        if (currentMode === 'trash') {
            nodes = nodes.filter(n => n !== hit);
            edges = edges.filter(ed => ed.from !== hit.id && ed.to !== hit.id);
        } else if (currentMode === 'link') {
            if (!linkSource) linkSource = hit;
            else if (linkSource !== hit) {
                if (!edges.find(x => (x.from === linkSource.id && x.to === hit.id) || (x.from === hit.id && x.to === linkSource.id)))
                    edges.push({from: linkSource.id, to: hit.id});
                linkSource = null;
            }
        } else {
            dragNode = hit;
            selectedNode = hit;
        }
    } else {
        const sHit = shapes.slice().reverse().find(s => isPointInShape(m.x, m.y, s));
        downInfo.hitShape = sHit || null;

        if (sHit && currentMode === 'select') {
            dragShape = sHit;
            lastMousePos = { x: m.x, y: m.y };
        } else {
            isDragging = true;
            selectedNode = null;
            lastMousePos = { x: e.clientX, y: e.clientY };
        }
    }

    draw();
}, { passive: false });

window.addEventListener('pointermove', (e) => {
    if (!pointers.has(e.pointerId)) return;

    pointers.set(e.pointerId, { clientX: e.clientX, clientY: e.clientY });

    // Pinch zoom
    if (isPinching && pointers.size >= 2) {
        const [p1, p2] = Array.from(pointers.values());
        const d = Math.max(1, distance(p1, p2));
        const scale = d / Math.max(1, pinchStartDist);
        const newZoom = pinchStartZoom * scale;

        // Zoom around the center between fingers
        const c = avgPoint(p1, p2);
        // Use screen-center to update zoom but preserve original world center
        const r = canvas.getBoundingClientRect();
        const mx = c.clientX - r.left;
        const my = c.clientY - r.top;

        zoom = Math.min(Math.max(0.1, newZoom), 5);
        offset.x = mx - pinchWorldCenter.x * zoom;
        offset.y = my - pinchWorldCenter.y * zoom;

        draw();
        e.preventDefault();
        return;
    }

    const m = getWorldFromClient(e.clientX, e.clientY);

    if (activeShape) {
        activeShape.w = m.x - activeShape.x;
        activeShape.h = m.y - activeShape.y;
        draw();
        e.preventDefault();
        return;
    }

    if (isDragging) {
        offset.x += e.clientX - lastMousePos.x;
        offset.y += e.clientY - lastMousePos.y;
        lastMousePos = { x: e.clientX, y: e.clientY };
    } else if (dragNode) {
        const dx = (e.clientX - lastMousePos.x) / zoom;
        const dy = (e.clientY - lastMousePos.y) / zoom;
        dragNode.x += dx;
        dragNode.y += dy;
        lastMousePos = { x: e.clientX, y: e.clientY };
    } else if (dragShape) {
        dragShape.x += (m.x - lastMousePos.x);
        dragShape.y += (m.y - lastMousePos.y);
        lastMousePos = { x: m.x, y: m.y };
    } else {
        // If finger is down on a node, start dragging once moved a bit (mobile "press and drag")
        if (downInfo && downInfo.hitNode) {
            const moved = Math.hypot(e.clientX - downInfo.clientX, e.clientY - downInfo.clientY);
            if (moved > 6) {
                dragNode = downInfo.hitNode;
                selectedNode = dragNode;
                lastMousePos = { x: e.clientX, y: e.clientY };
                downInfo = null;
            }
        }
    }

    draw();
    e.preventDefault();
}, { passive: false });

window.addEventListener('pointerup', (e) => {
    if (pointers.has(e.pointerId)) pointers.delete(e.pointerId);

    // End pinch when less than 2 pointers remain
    if (isPinching && pointers.size < 2) {
        isPinching = false;
        pinchStartDist = 0;
        pinchStartZoom = zoom;
    }

    if (activeShape) {
        if (Math.abs(activeShape.w) > 5 || Math.abs(activeShape.h) > 5) shapes.push(activeShape);
        activeShape = null;
    }

    // Determine tap vs drag (for mobile, tap should still "click")
    if (downInfo) {
        const dt = Date.now() - downInfo.time;
        const moved = Math.hypot(e.clientX - downInfo.clientX, e.clientY - downInfo.clientY);

        // If it was a quick tap (no significant move) and in select mode, select node/shape
        if (dt < 400 && moved < 8 && currentMode === 'select') {
            if (downInfo.hitNode) {
                selectedNode = downInfo.hitNode;
            } else if (downInfo.hitShape) {
                // nothing special besides keeping selection via dragShape mechanics
            } else {
                selectedNode = null;
            }
            draw();
        }
    }

    downInfo = null;
    isDragging = false;
    dragNode = null;
    dragShape = null;
    draw();
}, { passive: false });

window.addEventListener('pointercancel', () => {
    pointers.clear();
    isPinching = false;
    downInfo = null;
    isDragging = false;
    dragNode = null;
    dragShape = null;
    activeShape = null;
    draw();
}, { passive: false });

// Desktop wheel zoom stays as-is
canvas.onwheel = (e) => {
    e.preventDefault();
    setZoomAtScreenPoint(zoom * (e.deltaY > 0 ? 0.85 : 1.15), e.clientX, e.clientY);
    draw();
};

// Keep old helper (some parts call it), but base on client coords
function getMouse(e) {
    return getWorldFromClient(e.clientX, e.clientY);
};
        }

        function resize() { 
            const dpr = window.devicePixelRatio || 1;
            canvas.width = window.innerWidth * dpr; canvas.height = window.innerHeight * dpr; 
            canvas.style.width = window.innerWidth + 'px'; canvas.style.height = window.innerHeight + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            draw(); 
        }

        window.onload = async () => {
            resize(); await preRenderIcons();
            window.addEventListener('resize', resize);
            lucide.createIcons();
            updateThemeColor('#3b82f6');
        };
    </script>
</body>
</html>
